import 'dart:collection';

/// Common format of a metric data point
abstract class Point {
  /// Can store integer values
  double get value;

  /// Test name, unit, timestamp, configs, git revision, ..., in sorted order
  UnmodifiableMapView<String, String> get tags;

  /// Where this comes from. Used for dedup.
  String get sourceId;

  /// The last modified time. Can be null if it's not stored in the database yet.
  int get updateTimeNanos;

  /// Unique identifier for updating existing data point.
  ///
  /// This id should stay constant even if the tags map's keys are reordered.
  String get id;
}

/// Base implementation of [Point] used by the [MetricsCenter].
class BasePoint extends Point {
  BasePoint(
    this.value,
    Map<String, dynamic> tags,
    this.sourceId,
    this.updateTimeNanos,
  ) : this._tags = SplayTreeMap.from(tags) {}

  @override
  final double value;

  @override
  UnmodifiableMapView<String, String> get tags =>
      UnmodifiableMapView<String, String>(_tags);

  @override
  final String sourceId;

  @override
  final int updateTimeNanos; // the last modified time

  @override
  String get id => '$sourceId: $_tags';

  final SplayTreeMap<String, String> _tags;
}

/// Source must support efficient index on [Point.updateTimeNanos]
/// so we can query with a time range.
abstract class MetricsSource<SourcePoint extends Point> {
  /// Return points updated since timestamp [timeNanos] exclusively.
  /// (i.e., data with updateTimeNanos = [timeNanos] won't be returned.)
  ///
  /// The returned points should be sorted by their updateTimeNanos
  /// ascendingly.
  Future<Iterable<SourcePoint>> getUpdatesAfter(int timeNanos);

  /// The largest updateTimeNanos timestamp of any data we've pulled from this
  /// source.
  ///
  /// The timestamp is generated in this source, and this source may have a
  /// clock that's not in sync with the [MetricsCenter]'s clock.
  ///
  /// We only require that the source's clock is strictly increasing between
  /// batches: if [getUpdateAfter] already returned a list of data points with
  /// the largest [updateTimeNanos] = x, then the later updates must have
  /// strictly greater [updateTimeNanos] > x.
  int lastUpdateNanos;

  /// Unique id of the source. If this source is also a destination, then its
  /// corresponding destination (often the same object, e.g., [MetricsCenter])
  /// should have the same id.
  String get id;
}

abstract class MetricsDestination {
  /// Insert new data points or modify old ones with matching id.
  ///
  /// Deletion is done by setting [Point.value] to [double.nan].
  ///
  /// All points will set their updateTime to now in the destination.
  ///
  /// The destination could ignore some points and not store them. For the
  /// non-ignored points, it should faithfully store the value, tags, raw, and
  /// sourceId fields. Thus, if this destination is also a source (e.g., a
  /// [MetricsCenter]), then when [getUpdatesAfter] is called on the source, we
  /// should get the points with exactly the same fields that we just updated.
  /// This is especially important for the sourceId field which is used for
  /// dedup. Otherwise, there might be an update loop to generate an infinite
  /// amount of duplicate points.
  Future<void> update(Iterable<Point> points);

  /// The largest updateTimeNanos timestamp of any data we've pushed to this
  /// destination.
  ///
  /// This timestamp is generated by [MetricsCenter] (a [MetricsSource]) so its
  /// [updateTimeNanos] is strictly increasing between batches.
  int lastUpdateNanos;

  /// Unique id of the destination. If this destination is also a source, then
  /// its corresponding destination (often the same object, e.g.,
  /// [MetricsCenter]) should have the same id.
  String get id;
}

/// A central data warehouse to pull metrics from multiple sources, and send
/// them to multiple destinations for consumption.
abstract class MetricsCenter
    implements MetricsSource<BasePoint>, MetricsDestination {
  List<MetricsSource> otherSources;
  List<MetricsDestination> otherDestinations;

  Future<void> periodicallySync() async {
    await Future.wait(otherSources.map(pullFromSource));
    await Future.wait(otherDestinations.map(pushToDestination));
  }

  Future<void> pushToDestination(MetricsDestination destination) async {
    // To dedup, do not send data from that destination. This is important as
    // some destinations are also sources (e.g., a [MetricsCenter]).
    Iterable<Point> points =
        (await getUpdatesAfter(destination.lastUpdateNanos)).where(
      (p) => p.sourceId != destination.id,
    );
    await destination.update(points);
    destination.lastUpdateNanos = points.last.updateTimeNanos;
  }

  Future<void> pullFromSource(MetricsSource source) async {
    // To dedup, don't pull any data from other sources. This is important as
    // some sources are also destinations (e.g., [MetricsCenter]), and data from
    // other sources could be pushed there.
    Iterable<Point> points =
        (await source.getUpdatesAfter(source.lastUpdateNanos))
            .where((p) => p.sourceId == source.id);
    await update(points);
    source.lastUpdateNanos = points.last.updateTimeNanos;
  }
}

/// Some common tag keys
const String kGitRepoKey = 'gitRepo';
const String kGitRevisionKey = 'gitRevision';
const String kSourceIdKey = 'sourceId';
const String kTaskNameKey = 'taskName';
const String kUnitKey = 'unit';
const String kNameKey = 'name';

/// Some constants
const int kMinTimeNanos = -(1 << 53);

/// Known source/destination ids
const String kCocoonId = 'cocoon';
const String kSkiaPerfId = 'skiaperf';

/// Known repo url
const String kFlutterFrameworkRepo = 'https://github.com/flutter/flutter';
const String kFlutterEngineRepo = 'https://github.com/flutter/engine';
