import '../common.dart';

import 'common.dart';
import 'destination.dart';
import 'source.dart';

// TODO(liyuqian): issue 1. support batching so we won't run out of memory
// TODO(liyuqian): issue 2. integrate info/error logging if the list is too
// large.
class FlutterCenter implements MetricSource, MetricDestination {
  static Future<FlutterCenter> makeFromCredentialsJson(
      Map<String, dynamic> json) async {
    final adaptor = await DatastoreAdaptor.makeFromCredentialsJson(json);
    return FlutterCenter._(adaptor);
  }

  @override
  String get id => kFlutterCenterId;

  @override
  Future<void> update(List<MetricPoint> points) => _internalDst.update(points);

  @override
  Future<List<MetricPoint>> getUpdatesAfter(DateTime timestamp) =>
      _internalSrc.getUpdatesAfter(timestamp);

  /// Call this method periodically to synchronize metric points among mutliple
  /// sources and destinations.
  ///
  /// This method does
  /// 1. Pull data from other sources into this center.
  /// 2. Set sourceTime of the newly added points.
  /// 3. Push data from this center to other destinations.
  Future<void> synchronize() async {
    await Future.wait(_otherSources.map(_pullFromSource));
    await _internalSrc.updateSourceTime();
    await Future.wait(_otherDestinations.map(_pushToDestination));
  }

  Future<void> _pushToDestination(MetricDestination destination) async {
    // To dedup, do not send data from that destination. This is important as
    // some destinations are also sources (e.g., a [MetricsCenter]).
    List<MetricPoint> points =
        (await getUpdatesAfter(_dstUpdateTime[destination.id]))
            .where(
              (p) => p.originId != destination.id,
            )
            .toList();
    await destination.update(points);
    assert(points.last.sourceTime != null);
    _dstUpdateTime[destination.id] = points.last.sourceTime;
  }

  Future<void> _pullFromSource(MetricSource source) async {
    // To dedup, don't pull any data from other sources. This is important as
    // some sources are also destinations (e.g., [MetricsCenter]), and data from
    // other sources could be pushed there.
    List<MetricPoint> points =
        (await source.getUpdatesAfter(_srcUpdateTime[source.id]))
            .where((p) => p.originId == source.id);
    await update(points);
    assert(points.last.sourceTime != null);
    _srcUpdateTime[source.id] = points.last.sourceTime;
  }

  // Map from a source id to the largest sourceTime timestamp of any data that
  // this center has pulled from it.
  //
  // The timestamp is generated in the source, and it may have a clock that's
  // not in sync with the [MetricsCenter]'s clock.
  //
  // We only require that the source's clock is strictly increasing between
  // batches: if [getUpdateAfter] already returned a list of data points with
  // the largest [sourceTime] = x, then the later updates must have strictly
  // greater [sourceTime] > x.
  Map<String, DateTime> _srcUpdateTime;

  // Map from a destination id to the largest sourceTime of any data that this
  // center has pushed to it.
  //
  // This timestamp is generated by [MetricsCenter] (a [MetricSource]) so its
  // [sourceTime] is strictly increasing between batches.
  Map<String, DateTime> _dstUpdateTime;

  List<MetricSource> _otherSources = [];
  List<MetricDestination> _otherDestinations = [];

  final FlutterSource _internalSrc;
  final FlutterDestination _internalDst;

  // TODO also construct with src and dst list
  FlutterCenter._(DatastoreAdaptor adaptor)
      : _internalDst = FlutterDestination(adaptor),
        _internalSrc = FlutterSource(adaptor);
}
